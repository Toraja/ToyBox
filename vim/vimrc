" {{{ || variables || ---
" filereadable() does not expand ~ (tilde) to home directory.
" Workaround is to use $HOME or expand()
if has('win32')
	let s:vimdir = expand("~/vimfiles")
else
	let s:vimdir = expand("~/.vim")
endif
" --- || variables || }}}

" {{{ || options || ---

" << system >>
set nocompatible						" do not use legacy mode
set encoding=utf-8
set fileencodings^=utf-8
if has('unix')
	set shell=/bin/bash
endif

" << looks and feel >>
set background=dark						" color scheme for dark background
if v:version >= 800						" suppress bell sound and flushing
	set belloff=all
else
	set visualbell t_vb=
endif
set t_Co=256							" enrich color
set number relativenumber				" show line number and distance relative to current line
if !&diff && (has('gui') || has('unix') || has('nvim'))
	set cursorline						" current line is underlined
endif
set nomodeline							" modeline brings security issue?
set nowrap								" line does not wrap
set scrolloff=5	sidescrolloff=1			" offset between cursor and the edge of window"
set sidescroll=1						" scroll minimal when cursor goes off the screen horizontally
if has('gui')
	set title
endif
set titlestring=%{getcwd()}				" current directory
set titlestring+=\ \|\ %F%a				" full path to the file and argument list info
if !empty(v:servername)
	set titlestring+=\ \|\ %{v:servername}	" server name such as 'VIM'
endif
set laststatus=2						" always display status bar
set showtabline=2						" always display tabline

" {{{ || Compose tabline || ---
function! MyTabLine()
	let l:tabline = ''
	for l:cnt in range(tabpagenr('$'))
		let l:tabpagecnt = l:cnt + 1

		" select the highlighting
		if l:tabpagecnt == tabpagenr()
			let l:tabline .= '%#TabLineSel#'
		else
			let l:tabline .= '%#TabLine#'
		endif

		" compose tabline
		let l:tabline .= ' '
		" Add '+' if one of the buffers in the tab page is modified
		let l:buflist = tabpagebuflist(l:tabpagecnt)
		" Add '+' if one of the buffers in the tab page is modified
		for l:bufnr in l:buflist
			if getbufvar(l:bufnr, "&modified")
				let l:tabline .= '+'
				break
			endif
		endfor
		" Add tab number
		let l:tabline .= l:tabpagecnt
		" Add window number if more than 1 is opened
		let l:wincnt = tabpagewinnr(l:tabpagecnt, '$')
		if l:wincnt > 1
			let l:tabline .= ':' . l:wincnt
		endif
		let l:tabline .= ' '
		" Add file name
		let l:winnr = tabpagewinnr(l:tabpagecnt)
		let l:curbufnr = l:buflist[l:winnr - 1]
		let l:fname = bufname(l:curbufnr)
		let l:fnamelen = strlen(l:fname)
		if l:fnamelen == 0
			" TODO distinguish Location List and Quickfix List
			if getbufvar(l:curbufnr, "&filetype") ==# 'qf'
				let l:tabline .= '[Loc List]'
			else
				let l:tabline .= '[No Name]'
			endif
		else
			" let l:tabline .= pathshorten(fnamemodify(l:fname, ':.'))
			let l:tabline .= fnamemodify(l:fname, ':t')
		endif
		let l:tabline .= ' '

		" attempt to limit tablabel characters
		" if l:fnamelen == 0
		" let l:fname = '[No Name]'
		" else
		" let l:shortfname = pathshorten(fnamemodify(l:fname, ':.'))
		" let l:shortfnamelen = strlen(l:shortfname)
		" if l:shortfnamelen > 15
		" let l:fname = l:shortfname[l:shortfnamelen - 15:l:shortfnamelen]
		" else
		" let l:fname = l:shortfname
		" endif
		" endif
		" let l:tabline .= l:fname . ' '
	endfor

	" after the last tab fill with TabLineFill and reset tab page nr
	" let l:tabline .= '%#TabLineFill#%T'
	" ^^ what's the trailing '%T'?
	let l:tabline .= '%#TabLineFill#'

	return l:tabline
endfunction

set tabline=%!MyTabLine()
" --- || Compose tabline|| }}}

" reverse the color of unselected tab
highlight TabLine term=reverse cterm=bold,reverse gui=reverse

" << editing >>
set tabstop=4 noexpandtab shiftwidth=4	" change tab width
set autoindent smartindent				" indentation support
set shiftround							" round tab width for > and < command
set fileformats=unix,dos,mac			" Prefer Unix over Windows over OSX formats
set listchars=tab:\|\                   " Show unvisible chars
set backspace=indent,eol,start			" Enable backspace to wrap line and delete break
set virtualedit=block					" Allow cursor to move beyond the EOL when visual-block mode
set iminsert=0 imsearch=-1				" prevent entering Japaneve input mode when entering insert and search mode
set shellslash							" always use forward slash
set formatoptions+=jmM
set nofixendofline                      " Preserve the current EOL state
set ttimeoutlen=0						" This prevents <Esc> to hang in input mode on Linux terminal
if has('persistent_undo')
	set undofile						" enable undo beyond sessions
	set undodir=$HOME/.vim/undo,$HOME/vimfiles/undo
endif

" << search >>
set ignorecase							" Do case insensitive matching
set smartcase							" Do smart case matching
set incsearch							" Incremental search
set hlsearch							" highlight the match
set matchpairs+=<:>						" % command jumps between <> as well

" << others >>
set directory=$HOME/.vim/swap,$HOME/vimfiles/swap,.			" directory to store swap. The directory needs to be created by hand.
" set backup backupdir=$HOME/.vim/bak,$HOME/vimfiles/bak,.	" directory to store backup. The directory needs to be created by hand.
set cpoptions+=Iy						" I:autoindent is not removed when moving to other lines
set whichwrap+=<,>						" allow <Left> and <Right> in move to other lines
set complete+=k							" ins-completion option (include dictionary search)
set completeopt=longest,menuone			" ins-completion mothod (complete to longest, display menu even though only one match)
set splitbelow splitright				" splitted windows goes to below or right
set showcmd								" Show (partial) command in status line.
set lazyredraw							" screen will not be redrawn till macro execution is done
set tags=./tags;,./TAGS;,tags;,TAGS;
set diffopt+=vertical
set sessionoptions=blank,curdir,folds,tabpages,winsize

" << command mode >>
set history=300
set wildignorecase						" command mode completion ignores case
set wildignore+=*.swp,*.bak,*.class		" ignore files this specified extentions on completion
set wildmenu							" display menu on command line completion
set wildmode=longest,full				" command mode completion method (complete to longest, complete one by one)
" --- || options || }}}

" {{{ || automatically enter paste mode when pasting || ---
if &term =~ "xterm"
	let &t_ti .= "\e[?2004h"
	let &t_te .= "\e[?2004l"
	let &pastetoggle="\e[201~"

	function! XTermPasteBegin(command)
		set paste
		return a:command
	endfunction

	nnoremap <special> <expr> <Esc>[200~ XTermPasteBegin("i")
	" This delays exiting Insert and Command mode by pressing <Esc>
	" inoremap <special> <expr> <Esc>[200~ XTermPasteBegin("")
	" cnoremap <special> <Esc>[200~ <Nop>
	" cnoremap <special> <Esc>[201~ <Nop>
endif
" --- || automatically enter paste mode when pasting || }}}

" {{{ || enable meta-key bindings || ---
if !get(s:, 'meta_key_bound') && has('unix') && !has('nvim')
	" fix meta-keys which generate <Esc>a .. <Esc>z
	" do this once only so that keymaps defined by plugin will not be overwritten with <Nop>
	let s:set_meta_to_esc = "set <M-%s>=\e%s"
	let s:map_esc_to_meta = "noremap%s \e%s <M-%s>"
	let s:map_meta_to_nop = "noremap%s <M-%s> <Nop>"
	let c = 'a'
	while c <= 'z'
		" lower case
		exec printf(s:set_meta_to_esc, c, c)
		exec printf(s:map_esc_to_meta, '!', c, c)
		exec printf(s:map_esc_to_meta, '', c, c)
		exec printf(s:map_meta_to_nop, '!', c)
		exec printf(s:map_meta_to_nop, '', c)
		" upper case - skip M-O as it is part of del key, ins key, F key and etc
		if c != 'o'
			let C = toupper(c)
			exec printf(s:set_meta_to_esc, C, C)
			exec printf(s:map_esc_to_meta, '!', C, C)
			exec printf(s:map_esc_to_meta, '', C, C)
			exec printf(s:map_meta_to_nop, '!', C)
			exec printf(s:map_meta_to_nop, '', C)
		endif
		let c = nr2char(1+char2nr(c))
	endwhile
	unlet c C

	" meta + special-keys
	" note: '[' cannot be mapped as it's part of some keycodes
	exec "set <M-$>=\e$"
	exec "set <M-#>=\e#"
	exec "set <M-*>=\e*"
	exec "set <M-+>=\e+"
	exec "set <M-->=\e-"
	exec "set <M-/>=\e/"
	exec "set <M-:>=\e:"
	exec "set <M-;>=\e;"
	exec "set <M-=>=\e="
	" exec "set <M-]>=\e]" " This causes vim to work funny
	exec "set <M-_>=\e_"
	exec "set <M-`>=\e`"

	for n in range(0, 9)
		exec "set <M-".n.">=\e".n
		exec "noremap! \e".n." <M-".n.">"
		exec "noremap \e".n." <M-".n.">"
		exec "noremap <M-".n."> <Nop>"
	endfor
	unlet n
endif
let s:meta_key_bound = 1
" --- || enable meta-key bindings || }}}

" {{{ || autocmd || ---
" augroup prevents duplicated effect by disabling previous effect of the same group
if has("autocmd")
	augroup buffer_init
		autocmd!
		" jump to the last position when reopening a file
		autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif
		" enter automatically into the files directory
		autocmd BufEnter * silent! lcd %:p:h
	augroup END

	" hightlight for unwanted spaces
	augroup highlighter
		autocmd!
		" highlight trailing whitespaces and mixed whitespaces except for help files
		" VimEnter does not do the job somehow
		if has('nvim')
			" SpellRare (under curl) does not work on nvim
			autocmd BufWinEnter,InsertEnter,InsertLeave * match Visual /\s\+$\| \+\t\+\|\t\+ \+/
		else
			autocmd BufWinEnter,InsertEnter,InsertLeave * match SpellRare /\s\+$\| \+\t\+\|\t\+ \+/
		endif
		autocmd FileType help silent! call matchdelete(1)
	augroup END

	function! s:PreviousTabStoreState()
		let s:tab_current = tabpagenr()
		let s:tab_last = tabpagenr('$')
	endfunction
	function! s:PreviousTabTabClosed()
		if s:tab_current > 1 && s:tab_current < s:tab_last
			exec 'tabp'
		endif
	endfunction
	augroup prev_tab
		autocmd!
		autocmd TabEnter,TabLeave * call s:PreviousTabStoreState()
		autocmd TabClosed * call s:PreviousTabTabClosed()
	augroup end

	augroup misc
		autocmd!
		" fix windows size on resizing vim
		autocmd VimResized * :wincmd =
		" disable relativenumber in quickfix window
		autocmd FileType qf setlocal norelativenumber
		" if has('nvim')
			" automatically enter terminal-mode
			" XXX this causes GoRun to enter insert mode
			" autocmd TermOpen * startinsert
		" endif
	augroup END
endif
" --- || autocmd || }}}

" {{{ || plugin loading || ---
if has('nvim')
	packadd cfilter
endif
" Loadng plugins must be before keymapping or they will override my keymappings!
if filereadable(s:vimdir . "/autoload/plug.vim")
	call plug#begin(s:vimdir . '/bundle')
	Plug 'junegunn/vim-plug'
	" git
	Plug 'tpope/vim-fugitive'
	Plug 'airblade/vim-gitgutter'
	Plug 'zivyangll/git-blame.vim'
	" look & feel
	" Plug 'powerline/powerline'	" error occurs and donno how to fix
	Plug 'vim-airline/vim-airline'
	Plug 'vim-airline/vim-airline-themes'
	" finder (path/dir/file/buffer/tac/etc.)
	Plug 'scrooloose/nerdtree' ", { 'on': 'NERDTreeToggle' }
	Plug 'dbakker/vim-projectroot'
	Plug 'majutsushi/tagbar', { 'on': 'TagbarToggle' }
	Plug 'ctrlpvim/ctrlp.vim'		" required by vim-go GoDecls
	Plug exists('fzfdir') ? fzfdir : '~/garage/tools/fzf'
	Plug 'junegunn/fzf.vim'
	" moving around
	Plug 'easymotion/vim-easymotion'
	Plug 'michaeljsmith/vim-indent-object'
	" editting
	Plug 'Yggdroot/indentLine'
	Plug 'scrooloose/nerdcommenter'
	Plug 'arthurxavierx/vim-caser'
	Plug 'tpope/vim-surround'
	Plug 'tpope/vim-eunuch'
	Plug 'jiangmiao/auto-pairs'
	Plug 'AndrewRadev/splitjoin.vim'
	Plug 'tpope/vim-repeat'
	Plug 'junegunn/vim-easy-align'
	Plug 'vim-syntastic/syntastic'
	Plug 'Chiel92/vim-autoformat' " autocmd ':Autoformat' in ftplugin of desired language so that it will not interfere with other plugins (such as vim-go)
	if has('nvim') " no completion for conventional vim as it takes so long to start up
		Plug 'Shougo/deoplete.nvim', { 'do': ':UpdateRemotePlugins' }
	endif
	Plug 'autozimu/LanguageClient-neovim', {
				\ 'branch': 'next',
				\ 'do': has('win32') ? 'powershell install.ps1' : 'bash install.sh',
				\ }
	Plug 'SirVer/ultisnips'
	Plug 'honza/vim-snippets'
	Plug 'vim-utils/vim-husk'
	" misc
	Plug 'tpope/vim-abolish'
	Plug 'tmux-plugins/vim-tmux-focus-events'
	Plug 'iamcco/markdown-preview.nvim', { 'do': { -> mkdp#util#install() }} " hook cannot be called (function not found) if language specific

	" Language specific
	Plug 'dag/vim-fish', { 'for': 'fish' }
	if executable('npm')
		Plug 'ternjs/tern_for_vim', { 'for': 'javascript', 'do': 'npm install' }
		Plug 'carlitux/deoplete-ternjs', { 'for': 'javascript', 'do': 'npm install -g tern' }
	endif
	Plug 'othree/jspc.vim', { 'for': 'javascript' }
	Plug 'jelera/vim-javascript-syntax', { 'for': 'javascript' }    " <- The order matters! First comes first serves (for syntax at least)
	Plug 'pangloss/vim-javascript', { 'for': 'javascript' }         " <- syntax of vim-javascript is ugly
	Plug 'myhere/vim-nodejs-complete', { 'for': 'javascript' }
	Plug 'moll/vim-node', { 'for': 'javascript' }
	Plug 'fatih/vim-go', { 'for': 'go', 'do': ':GoUpdateBinaries', 'tag': '*' }
	Plug 'plasticboy/vim-markdown', { 'for': 'markdown' }
	Plug 'mzlogin/vim-markdown-toc', { 'for': 'markdown' }
	Plug 'dhruvasagar/vim-table-mode', { 'for': 'markdown' }
	Plug 'cespare/vim-toml', { 'for': 'toml' }
	Plug 'PProvost/vim-ps1', { 'for': 'ps1' }
	Plug 'aklt/plantuml-syntax', { 'for': 'plantuml' }
	call plug#end()
else
	" these are called by plug#end()
	filetype plugin indent on
	syntax enable
endif
" --- || plugin loading || }}}

" {{{ || key mapping || ---

" {{{ || my mapping || ---
" {{{ || Leader || ---
noremap <Space> <Nop>
let mapleader = "\<Space>"
nnoremap <Leader> "z
vnoremap <Leader> "z

noremap <C-Space> <Nop>
noremap! <C-Space> <Nop>
" Use local leader for ftplugins
let maplocalleader = "\<C-Space>"
nnoremap <LocalLeader> "Z
vnoremap <LocalLeader> "Z

map ; [Chief]
if has('xterm_clipboard')
	nnoremap [Chief] "+
	vnoremap [Chief] "+
else
	nnoremap [Chief] "*
	vnoremap [Chief] "*
endif

map , [Captain]
nnoremap [Captain] "_
vnoremap [Captain] "_
" --- || Leader || }}}

" {{{ || cursor motion || ---
noremap j gj
noremap k gk
noremap <expr> <silent> <Home> col('.') == match(getline('.'),'\S')+1 ? '0' : '^'
map H <Home>
nnoremap L $
onoremap L $
vnoremap L g_
" J & K below is to prevent accidental line join and opening help
vnoremap J j
vnoremap K k

" {{{ || insert/command mode || ---
inoremap <C-b> <Left>
inoremap <C-f> <Right>
inoremap <M-f> <C-Right>
inoremap <M-b> <C-Left>
imap <silent> <Home> <C-o><Home>
imap <C-a> <Home>
inoremap <expr> <C-e> pumvisible() ? "\<C-e>" : "\<End>"
inoremap <C-p> <Up>
inoremap <C-n> <Down>
" --- || insert/command mode || }}}

" [go to next/last upper case character]
nnoremap <silent> <M-w> :call search("[A-Z_]", '', line('.'))<CR>
nnoremap <silent> <M-b> :call search("[A-Z_]", 'b', line('.'))<CR>
vnoremap <silent> <M-w> ompo<Esc>:call search("[A-Z_]")<CR>vg`po
vnoremap <silent> <M-b> ompo<Esc>:call search("[A-Z_]", 'b')<CR>vg`po
" [always search forward/backword]
" noremap <expr> <Bslash> getcharsearch().forward ? ';' : ','
" noremap <expr> <Bar> getcharsearch().forward ? ',' : ';'
vnoremap al ggoG$
" all
onoremap <silent> al :normal! VggoG<CR>
" line without indent
onoremap <silent> u :normal! ^v$h<CR>
" line including indent
onoremap <silent> U :normal! 0v$h<CR>
onoremap <silent> im :call SelectCamelWord()<CR>
vnoremap <silent> im :<C-u>call SelectCamelWord()<CR>
" XXX these do not work if the cursor is on the last element
" as in /cursor/is/he|re
onoremap <silent> ad :call SelectPair('${', '', '}', 1)<CR>
vnoremap <silent> ad :<C-u>call SelectPair('${', '', '}', 1)<CR>
onoremap <silent> ie :call SelectElement()<CR>
vnoremap <silent> ie :<C-u>call SelectElement()<CR>
vnoremap <silent> i, T,ot,
onoremap <silent> i, :normal! T,vt,<CR>
vnoremap <silent> a, T,of,
onoremap <silent> a, :normal! T,vf,<CR>
vnoremap <silent> i. T.ot.
onoremap <silent> i. :normal! T.vt.<CR>
vnoremap <silent> a. T.of.
onoremap <silent> a. :normal! T.vf.<CR>
vnoremap <silent> i/ T/ot/
onoremap <silent> i/ :normal! T/vt/<CR>
vnoremap <silent> a/ T/of/
onoremap <silent> a/ :normal! T/vf/<CR>
vnoremap <silent> iu T_ot_
onoremap <silent> iu :normal! T_vt_<CR>
vnoremap <silent> au T_of_
onoremap <silent> au :normal! T_vf_<CR>
nnoremap [Chief]v :call SetOperatorFunc('VisualOperator')<CR>g@
function! VisualOperator(operatortype)
	if a:operatortype ==# 'v'
		normal! `<v`>
	else
		normal! `[v`]
	endif
endfunction
" --- || cursor motion || }}}

" {{{ || scrolling || ---
noremap <C-u> 5<C-u>
noremap <C-d> 5<C-d>
noremap <M-y> zh
noremap <M-e> zl
noremap <M-Y> zH
noremap <M-E> zL
" --- || scrolling || }}}

" {{{ || tag || ---
nnoremap [t <C-t>
nnoremap ]t :tag<CR>
" [always use 'tjumg']
nnoremap [Chief]<C-]> <C-w><C-v>g<C-]>
nnoremap <C-]> g<C-]>
nnoremap g<C-]> <C-]>
nnoremap <C-t><C-]> :tab stjump <C-r><C-w><CR>
" --- || tag || }}}

" {{{ || editing || ---
nnoremap <M-x> "_x
nnoremap <M-X> "_X
nnoremap <expr> p IsRegMultiline(v:register) ? "p=']" : "p"
nnoremap <expr> P IsRegMultiline(v:register) ? "P=']" : "P"
nnoremap <expr> gp IsRegMultiline(v:register) ? "p'[=']']" : "p"
nnoremap <expr> gP IsRegMultiline(v:register) ? "P'[=']']" : "P"
nnoremap [Captain]p p
nnoremap [Captain]P P
vnoremap p "_c<C-r>"<Esc>
vnoremap P "_c<C-r>"<Esc>
" [insert/command mode]
inoremap <C-w> <C-g>u<C-w>
inoremap <C-u> <C-g>u<C-u>
cnoremap <expr> <C-q> Expander()
inoremap <expr> <C-y> pumvisible() ? "\<C-y>" : "<C-g>u\<C-r>\""
cnoremap <expr> <C-y> wildmenumode() ? "\<C-e>" : "\<C-r>\""
noremap! <M-y> <C-r>*
inoremap <C-d> <DEL>
inoremap <M-d> <C-g>u<C-\><C-o>"_dw
inoremap <C-k> <C-g>u<C-\><C-o>"_D
inoremap <M-h> <C-g>u<C-w>
cnoremap <M-h> <C-w>
inoremap <M-n> <C-e>
inoremap <M-p> <C-y>
inoremap <M-t> <C-d>
" [UPPER/lowercase & Capitalize]
inoremap <M-u> <Esc>gUiwea
inoremap <M-l> <Esc>guiwea
inoremap <M-c> <Esc>guiwgU<right>ea
" [Line break/join]
nnoremap <expr> <CR> &filetype == 'qf' ? "\<CR>" : "i\<CR>\<Esc>"
nnoremap <M-m> mpo<Esc>0Dg`p|	"insert blank line below
nnoremap <M-M> mpO<Esc>0Dg`p|	"insert blank line above
nnoremap <C-j> o<Esc>
nnoremap <M-j> O<Esc>
inoremap <C-j> <Esc>o
inoremap <M-j> <Esc>O
" [Other editing]
vnoremap y ygv<Esc>|	"place cursor after the selection when yanking
noremap Y y$
vnoremap <silent> <C-a> <C-a>gv
vnoremap <silent> <C-x> <C-x>gv
nnoremap <silent> g<C-a> :call search("[0-9]", 'be', line('.'))<CR><C-a>
nnoremap <silent> g<C-x> :call search("[0-9]", 'be', line('.'))<CR><C-x>
nnoremap d. /\s\+$<CR>"_dgn|	" delete trailing spaces
" [move line]
" nnoremap <silent> <expr> <M-j> ":\<C-u>silent! move .+".v:count1."\<CR>=="
" nnoremap <silent> <expr> <M-k> ":\<C-u>silent! move .-".(v:count1+1)."\<CR>=="
" ones for visual mode requires range ('<,'>) to work as intended
" vnoremap <silent> <expr> <M-j> ":\<C-u>silent! '<,'>move '>+".(v:count1)."\<CR>gv=gv"
" vnoremap <silent> <expr> <M-k> ":\<C-u>silent! '<,'>move '<-".(v:count1+1)."\<CR>gv=gv"
" [undo redo]
nnoremap U <Nop>
inoremap <C-_> <C-o>u
inoremap <C-/> <C-o>u
inoremap <M-/> <C-o><C-r>
" [set undo break before commands below]
inoremap <Space> <C-g>u<Space>
inoremap <C-m> <C-g>u<C-m>
inoremap . .<C-g>u
" --- || editing || }}}

" {{{ || register || ---
" used registers
" r: RedirCmdOutputToReg
" keymap for "z, "Z is defined in leader section
nnoremap "" :registers<CR>
nnoremap <Leader><Space> :call CopyRegisterToAnother('"', 'z')<CR>
if has('xterm_clipboard')
	nnoremap [Chief]; :call CopyRegisterToAnother('"', '+')<CR>
elseif has('clipboard')
	nnoremap [Chief]; :call CopyRegisterToAnother('"', '*')<CR>
endif
nnoremap <Leader>r :call CopyRegisterToAnotherInteract()<CR>
nnoremap <expr> [Chief]r SetRegister()
nnoremap <expr> [Captain]r EditRegister()

function! CopyRegisterToAnother(regFrom, regTo)
	execute "let @" . a:regTo . " = @" . a:regFrom
	execute "let l:regToCont = @" . a:regTo
	echo "@" . a:regTo . " = " . l:regToCont
endfunction

function! CopyRegisterToAnotherInteract()
	registers
	echo 'Enter register character to copy from:'
	let l:regcharFrom = nr2char(getchar())
	echo 'Enter register character to save into:'
	let l:regcharTo = nr2char(getchar())

	call CopyRegisterToAnother(l:regcharFrom, l:regcharTo)
endfunction

function! SetRegister()
	echo 'Enter register character to set:'
	return ":call setreg('".nr2char(getchar())."','')\<Left>\<Left>"
endfunction

function! EditRegister()
	echo 'Enter register character to edit:'
	let l:regchar = nr2char(getchar())
	" Using getreg() to get the register contents causes trouble
	" if the register contains line feed/carriage return,
	" so keybind is used instead.
	return ":call setreg('".l:regchar."','\<C-r>".l:regchar."')\<Left>\<Left>"
endfunction

" clear contents of all char registers
function! ClearCharRegisters()
	let c='a'
	while c <= 'z'
		execute setreg(c, [])
		let c = nr2char(1+char2nr(c))
	endwhile
endfunction

command! -nargs=+ CopyRegisterToAnother :call CopyRegisterToAnother(<f-args>)
command! ClearCharRegisters :call ClearCharRegisters()
" --- || register || }}}

" {{{ || Mark || ---
noremap ' `
noremap ` '
nnoremap <Leader>m :<C-u>marks<CR>
" --- || Mark || }}}

" {{{ || Completion || ---
inoremap <expr> <C-l> pumvisible() ? "\<C-n>" : "\<C-x>\<C-n>"
inoremap <expr> <C-i> pumvisible() ? "\<C-n>" : "\<C-x>\<C-o>"
" --- || Completion || }}}

" {{{ || Search || ---
" AnnoyingSpaces: trailing white spaces or mixture of space and tab
let g:AnnoyingSpaces = "\\s\\+$\\| \\+\\t\\+\\|\\t\\+ \\+"
" open fold which the match belongs to so that you can view where exactly the
" match is.
nnoremap n nzx
nnoremap N Nzx
nnoremap <silent> [Captain]/ :let @/ = ''<CR>
" TODO change these to use function like QuickGrep
nnoremap <silent> * :let @/="\\V<C-r><C-w>"<CR>:call histadd("search", @/)<CR>:set hlsearch<CR>
nnoremap <silent> g* :let @/="\\<<C-r><C-w>\\>"<CR>:call histadd("search", @/)<CR>:set hlsearch<CR>
nnoremap <silent> <M-*> :let @/="\\V\\C<C-r><C-w>"<CR>:call histadd("search", @/)<CR>:set hlsearch<CR>
nnoremap <silent> g<M-*> :let @/="\\C\\<<C-r><C-w>\\>"<CR>:call histadd("search", @/)<CR>:set hlsearch<CR>
nnoremap <silent> <Leader>* :let @/="\\V<C-r>=escape(expand("<cWORD>"), "/\"")<CR>"<CR>:call histadd("search", @/)<CR>:set hlsearch<CR>
vnoremap <silent> * y:let @/="\\V<C-r>=escape(@@, "/\"")<CR>"<CR>:call histadd("search", @/)<CR>:set hlsearch<CR>
vnoremap <silent> g* y:let @/="\\V\\<<C-r>=escape(@@, "/\"")<CR>\\>"<CR>:call histadd("search", @/)<CR>:set hlsearch<CR>
nnoremap <C-g> /<C-r><C-w>
xnoremap <C-g> y/<C-r>"
nnoremap g<C-g> /\<Lt><C-r><C-w>\>
xnoremap g<C-g> y\<Lt>/<C-r>"\>
nnoremap g[i :psearch /<C-r><C-w>/<CR>
" [toggle highlight]
if exists('v:hlsearch')
	nnoremap <silent> <expr> <M-u> (&hlsearch && v:hlsearch ? ':nohlsearch<CR>' : ':set hlsearch<CR>')
else
	nnoremap <silent> <M-u> :set hlsearch! hlsearch?<CR>
endif
" --- || Search || }}}

" {{{ || Grep || ---
" COMBAK make it like QuickSubstitute() and take dictionary arguments?
" Lets you run lvimgrep quickly and open quickfix window
" @pattern string to grep
" @modify when non-zero, let the user modify the argument for vimgrep
function! QuickGrep(pattern, modify)
	let l:grepArg = printf('/\V%s/gj %%', a:pattern)

	if a:modify
		let l:cursorAdjustment = repeat("\<Left>", 5)
		let l:grepArg = Input(v:true, ':lvimgrep ', l:grepArg . l:cursorAdjustment)
		if l:grepArg is 0
			return
		endif
	endif

	try
		silent execute 'lvimgrep ' . l:grepArg
	catch /^Vim\%((\a\+)\)\=:E480/	" catch error E480 - No match found
		echohl WarningMsg | echo 'No match found' | echohl NONE
		" 'lclose' in case location list is already opened
		silent lclose
		return
	endtry

	call QFOpenSmart(s:quickfix_mode_location, 0)
endfunction
nnoremap <silent> [Captain]g :call QuickGrep('', 1)<CR>
nnoremap <silent> + :call QuickGrep(expand("<cword>"), 0)<CR>
nnoremap <silent> g+ :call QuickGrep('\<'.expand("<cword>").'\>', 0)<CR>
nnoremap <silent> <Leader>+ QuickGrep(expand("<cWORD>"), 0)<CR>
vnoremap <silent> + y:call QuickGrep(@@, 0)<CR>
vnoremap <silent> g+ y:call QuickGrep('\<'.@@.'\>', 0)<CR>
" --- || Grep || }}}

" {{{ || Replace || ---
" Lets you run substitute quickly
" @pattern string to find
" @options available options are:
"			range:		same as [range] command parameter.
"			selection:	none-zero means search area is only within selection
"			case:		none-zero means case sensitive
"			exclusive:	none-zero means pattern will be wrapped with \< \>
function! QuickSubstitute(corePattern, options)
	let l:optKeyRange = 'range'
	let l:optKeyCase = 'case'
	let l:optKeyExclusive = 'exclusive'
	let l:optKeySelection = 'selection'
	let l:baseSubstituteCmd = '%ssubstitute/%s\V//gc'

	let l:range = has_key(a:options, l:optKeyRange) ? a:options[l:optKeyRange] : ''

	let l:searchPattern = ''
	if has_key(a:options, l:optKeySelection)
		let l:searchPattern .= a:options[l:optKeySelection] ? '\%V' : ''
	endif
	if has_key(a:options, l:optKeyCase)
		let l:searchPattern .= a:options[l:optKeyCase] ? '\C' : ''
	endif
	" check for exclusive should be the last so that pattern string comes after ordinary atoms
	if has_key(a:options, l:optKeyExclusive) && a:options[l:optKeyExclusive] == 1
		let l:searchPattern .= '\<' . a:corePattern . '\>'
	else
		let l:searchPattern .= a:corePattern
	endif

	let l:substituteCmd = printf(l:baseSubstituteCmd, l:range, l:searchPattern)

	let l:cursorAdjustment = repeat("\<Left>", a:corePattern == '' ? 4 : 3)
	let l:substituteCmd = Input(v:true, ':', l:substituteCmd . l:cursorAdjustment)
	if l:substituteCmd is 0
		return
	endif

	try
		execute l:substituteCmd
	catch /^Vim\%((\a\+)\)\=:E486/	" catch error E486 - Pattern not found
		echohl WarningMsg | echo 'Pattern not found' | echohl NONE
		return
	endtry
endfunction
nnoremap [Captain]s  :call QuickSubstitute('', {'range': '%'})<CR>
nnoremap [Captain]S  :call QuickSubstitute('', {})<CR>
nnoremap <Leader>s   :call QuickSubstitute(expand("<cword>"), {'range': '%'})<CR>
nnoremap <Leader>S   :call QuickSubstitute(expand("<cword>"), {'range': '%', 'case': 1})<CR>
nnoremap [Chief]s    :call QuickSubstitute(expand("<cword>"), {'range': '%', 'exclusive': 1})<CR>
nnoremap [Chief]S    :call QuickSubstitute(expand("<cword>"), {'range': '%', 'exclusive': 1, 'case': 1})<CR>
vnoremap [Captain]s  :call QuickSubstitute('', {'range': '%', 'selection': 1})<CR>
vnoremap [Captain]S  :call QuickSubstitute(@@, {'range': '%', 'selection': 1})<CR>
vnoremap <Leader>s  y:call QuickSubstitute(@@, {'range': '%'})<CR>
vnoremap <Leader>S  y:call QuickSubstitute(@@, {'range': '%', 'case': 1})<CR>
vnoremap [Chief]s   y:call QuickSubstitute(@@, {'range': '%', 'exclusive': 1})<CR>
vnoremap [Chief]S   y:call QuickSubstitute(@@, {'range': '%', 'exclusive': 1, 'case': 1})<CR>
" --- || Replace || }}}

" {{{ || Quickfix/Location || ---
function! s:QuickfixDict()
	return {
				\ 'o': 'QFOpenSmart! '. s:quickfix_mode,
				\ 'q': 'ToggleQFWindow ' . s:quickfix_mode,
				\ 'g': s:quickfix_mode,
				\ 'n': 'next',
				\ 'p': 'previous',
				\ 'a': 'first',
				\ 'e': 'last',
				\ 'j': 'nfile',
				\ 'k': 'pfile',
				\ 'b': 'bottom',
				\ 'y': 'history',
				\ 'h': 'older',
				\ 'l': 'newer',
				\ 'm': printf('call SwitchQFMode() " (current: %s)', s:quickfix_mode),
				\}
endfunction

let s:quickfix_cmd_config = {
			\ 'no_prepend_mode': ['o', 'q', 'm'],
			\ 'no_count': ['o', 'q', 'b', 'y', 'm'],
			\}

function! s:PrependQuickfixMode(key, val)
	if index(s:quickfix_cmd_config.no_prepend_mode, a:key) >= 0
		return a:val
	endif
	return s:quickfix_mode . a:val
endfunction

function! QuickfixCmd(count, cmds)
	let l:title = s:quickfix_mode_names[s:quickfix_mode]
	call DispOptionsOneLine(l:title, {'<Space>': 'Display commands'})

	let l:cmd_dict = map(copy(a:cmds), function('s:PrependQuickfixMode'))

	while v:true
		let l:user_input = GetChar(v:true)
		if l:user_input is 0
			return
		endif
		if l:user_input == "\<Space>"
			redraw
			call DispOptions(l:title . ':', l:cmd_dict, 'Press a key: ')
			continue
		else
			break
		endif
	endwhile
	redraw

	if IsCtrlAlpha(l:user_input)
		let l:user_input = ConvertCtrlCharToNormal(l:user_input, 1)
	endif

	let l:cmd = get(l:cmd_dict, l:user_input, '')
	if l:cmd == ''
		echohl WarningMsg | echo printf('"%s" is not available.', l:user_input) | echohl NONE
		return
	endif

	let l:count = (a:count == 0) ? "" : a:count
	if index(s:quickfix_cmd_config.no_count, l:user_input) < 0
		let l:cmd = printf('%s %s', l:cmd, l:count)
	endif

	try
		execute l:cmd
	catch /^Vim\%((\a\+)\)\=:E\(42\|776\):/
		echohl WarningMsg | echo 'No error in the list' | echohl NONE
		return
	catch
		redraw
		echohl ErrorMsg | echo printf('%s: %s', v:throwpoint, v:exception) | echohl NONE
	endtry
endfunction
nnoremap <silent> <C-q> :<C-u>call QuickfixCmd(v:count, <SID>QuickfixDict())<CR>

" value is l and c so that these can be simply prepended to quickfix commands
let [s:quickfix_mode_location, s:quickfix_mode_quickfix] = ['l', 'c']
let s:quickfix_mode = get(s:, 'quickfix_mode', s:quickfix_mode_location)
let s:quickfix_mode_names = {
			\ s:quickfix_mode_location: 'Location',
			\ s:quickfix_mode_quickfix: 'Quickfix',
			\}

" Toggle quickfix mode if no argument is supplied.
" Change to the mode if an argument is supplied.
" @1: mode to change
function! SwitchQFMode(...)
	if a:0 >= 1
		let l:mode_to_change = a:1
		let l:quickfix_modes = [s:quickfix_mode_location, s:quickfix_mode_quickfix]
		if index(l:quickfix_modes, l:mode_to_change) < 0
			echoerr 'Invalid Argument: must be either ' . string(l:quickfix_modes)
			return
		endif
		if s:quickfix_mode == l:mode_to_change
			return
		endif
	endif

	let l:mode_from = s:quickfix_mode_names[s:quickfix_mode]
	let s:quickfix_mode = s:quickfix_mode == s:quickfix_mode_location ?
				\ s:quickfix_mode_quickfix : s:quickfix_mode_location
	let l:mode_to = s:quickfix_mode_names[s:quickfix_mode]
	echo printf('Quickfix mode changed from %s to %s', l:mode_from, l:mode_to)
endfunction

" Open quickfix/location list with just enough height for errors but
" no more than the maximum. Close window if no error is found.
" @qftype [number] quickfix of location
" @focus [boolean] whether to focus on quickfix window
" @return [number] the number of errors in location list
function! QFOpenSmart(qftype, focus) abort
	let l:numerror = a:qftype == s:quickfix_mode_location ?
				\ len(getloclist(0)) : len(getqflist())
	if !l:numerror
		execute a:qftype.'close'
		return 0
	endif

	silent call SwitchQFMode(a:qftype)

	const l:maxheight = 10
	let l:qfheight = (l:numerror > l:maxheight) ? l:maxheight : l:numerror
	execute a:qftype.'open'.l:qfheight
	if !a:focus
		wincmd p
	endif

	return l:numerror
endf
command! -bang -nargs=1 QFOpenSmart call QFOpenSmart(<f-args>, <bang>0)

function! ToggleQFWindow(qftype) abort
	let l:key = 'winid'
	let l:opt = {l:key: 1}
	let l:winid = a:qftype == s:quickfix_mode_quickfix ? getqflist(l:opt)[l:key] : getloclist(0, l:opt)[l:key]
	if l:winid
		execute win_id2win(l:winid) . 'close'
		return
	endif
	call QFOpenSmart(a:qftype, 0)
endfunction
command! -nargs=1 ToggleQFWindow call ToggleQFWindow(<q-args>)
" --- || Quickfix/Location || }}}

" {{{ || Buffer || ---
command! BufOnly %bdelete | edit#
" --- || Buffer || }}}

" {{{ || Window || ---
nnoremap <silent> <C-w>O :only!<CR>
nnoremap <C-w>B :bdelete<CR>
" --- || Window || }}}

" {{{ || Tab || ---
noremap <C-t> <Nop>
nnoremap <silent> <expr> <C-t><C-n> ":\<C-u>".(v:count ? v:count : "")."tabnew\<CR>"
nnoremap <silent> <expr> <C-t><C-o> ":\<C-u>".(v:count ? v:count : "")."tabonly\<CR>"
nnoremap <silent> <expr> <C-t><C-q> ":\<C-u>".(v:count ? v:count : "")."tabclose\<CR>"
nnoremap <silent> <expr> <C-t><C-d> ":\<C-u>".(v:count ? v:count : "")."tab split\<CR>"
nnoremap <silent> <C-t><CR> <C-w><CR><C-w>T
nnoremap <C-t><C-f> <C-w>gf
nnoremap <C-n> gt
nnoremap <C-p> gT
nnoremap <silent> <expr> <M-n> ":\<C-u>silent! tabmove+".v:count1."<CR>"
nnoremap <silent> <expr> <M-p> ":\<C-u>silent! tabmove-".v:count1."<CR>"
for n in range(1, 9)
	execute printf("nnoremap <M-%s> %sgt", n, n)
endfor
unlet n
nnoremap <M-0> 10gt
" jump to last active tab
if has('autocmd')
	let g:lasttabnum = 1
	augroup last_tab
		autocmd!
		autocmd TabLeave * let g:lasttabnum = tabpagenr()
	augroup END
	nnoremap <silent> <C-t><C-t> :execute "tabnext " . g:lasttabnum<CR>
endif
" --- || Tab || }}}

" {{{ || Suspend/Close/Exit || ---
nnoremap ZB :bdelete!<CR>
nnoremap ZT :windo quit!<CR>
nnoremap <C-w><C-e> :confirm tabonly<CR>:bufdo confirm bdelete<CR>
nnoremap <C-w><C-a> :windo confirm quit<CR>
nnoremap <C-w>A :confirm qall<CR>
" --- || Suspend/Close/Exit || }}}

" {{{ || Terminal || ---
tnoremap <C-\><C-\> <C-\><C-n>
if &shell =~ 'cmd'
	tnoremap <C-p> <Up>
	tnoremap <C-n> <Down>
	tnoremap <C-f> <Right>
	tnoremap <C-b> <Left>
	tnoremap <M-f> <C-Right>
	tnoremap <M-b> <C-Left>
	tnoremap <C-a> <Home>
	tnoremap <C-e> <End>
	tnoremap <C-d> <Del>
	tnoremap <C-u> <Esc>
endif

" --- || Terminal || }}}

" {{{ || Others || ---
map <S-Space> <Space>
nnoremap <C-s> :update<CR>
nnoremap <F1> K
if has('gui')
	nnoremap <F3> :source $MYVIMRC<CR>:source $MYGVIMRC<CR>
else
	nnoremap <F3> :source $MYVIMRC<CR>
endif
nnoremap <Leader><F3> :tabnew $MYVIMRC<CR>
nnoremap [Chief]<F3> :call OpenFtplugins(&ft)<CR>
nnoremap [Captain]<F3> :SetFt<CR>
nnoremap Q gQ
noremap [Chief]: :<C-p>
nnoremap <silent> <Leader>b :buffers<CR>
" [insert/command mode]
cnoremap <C-j> <Tab>
inoremap <M-o> <C-\><C-o>
cnoremap <expr> <C-p> wildmenumode() ? "\<C-p>" : "\<Up>"
cnoremap <expr> <C-n> wildmenumode() ? "\<C-n>" : "\<Down>"
cnoremap <M-i> <C-d>
cnoremap <M-@> <Home>let @" = '<End>'
" retry triggering abbreviation
inoremap <C-g><C-]> <Esc>ciw<C-r>"<C-]>
" --- || Others || }}}

" --- || my mapping || }}}

" {{{ || plugin mapping and option || ---

" {{{ || vim-fugitive || ---
if exists('g:plugs["vim-fugitive"]')
	let g:fugitive_no_maps = 1
	cnoreabbrev gs Gstatus
	cnoreabbrev gl Git log
	cnoreabbrev glg vertical sbuffer <Bar> Gllog
	cnoreabbrev gcm Gcommit -m
	cnoreabbrev gd Gdiffsplit
	nnoremap <C-t>gs :tab Gstatus<CR>
	nnoremap <C-t>gl :tab Git log<CR>
	nnoremap [Chief]gs :vert Gstatus<CR>
	nnoremap [Chief]gl :vert Git log<CR>
endif
" --- || vim-fugitive || }}}

" {{{ || vim-gitgutter || ---
if exists('g:plugs["vim-gitgutter"]')
	let g:gitgutter_preview_win_floating = 0
endif
" --- || vim-fugitive || }}}

" {{{ || powerline / airline || ---
if !(exists('g:plugs["powerline"]') || exists('g:plugs["vim-airline"]'))
	set statusline=(%{winnr()})				" window number
	set statusline+=%f						" relative path
	set statusline+=[%{strlen(&fenc)?&fenc:'none'},%{&ff}]	" [file encoding,file format]
	set statusline+=%y%r%m					" file type; readonly flag; modified flag
	set statusline+=%=%c,%l/%L%6.6P			" right align; current column,line/total line; percentage with fixed width of 6 chars
endif
if exists('g:plugs["powerline"]')
	set noshowmode
	python3 from powerline.vim import setup as powerline_setup
	python3 powerline_setup()
	python3 del powerline_setup
elseif exists('g:plugs["vim-airline"]')
	set noshowmode
	let g:airline_theme='cool'
	let g:airline_section_c = '(%{winnr()}) %<%F%m %#__accent_red#%{airline#util#wrap(airline#parts#readonly(),0)}%#__restore__#'
endif
" --- || powerline / airline || }}}

" {{{ || NERDCommenter || ---
if exists('g:plugs["nerdcommenter"]')
	let g:NERDSpaceDelims = 1				" Add spaces after comment delimiters
	let g:NERDDefaultAlign = 'left'
	nnoremap <silent> <C-\> :call NERDComment("n","toggle")<CR>
	vnoremap <silent> <C-\> :call NERDComment("n","toggle")<CR>
	inoremap <silent> <C-\> <C-o>:call NERDComment("n","toggle")<CR>
endif
" --- || NERDCommenter || }}}

" {{{ || NERDTree || ---
if exists('g:plugs["nerdtree"]')
	let g:NERDTreeShowLineNumbers = 1
	let g:NERDTreeSortHiddenFirst = 1
	let g:NERDTreeShowHidden=1
	let g:NERDTreeQuitOnOpen=1
	" call NERDTreeAddKeyMap({
	"     \ 'key': 'J',
	"     \ 'callback': {-> feedkeys('gt')},
	"     \ 'quickhelpText': 'use my own J mapping',
	"     \ 'scope': 'Node',
	"     \ 'override': 1})
	" call NERDTreeAddKeyMap({
	"     \ 'key': 'K',
	"     \ 'callback': {-> feedkeys('gt')},
	"     \ 'quickhelpText': 'use my own K mapping',
	"     \ 'scope': 'Node',
	"     \ 'override': 1})
	" NERDTreeAddKeyMap() overrides keybinds only with the same scope
	" (J/K are 'Node' scope)
	" So use autocmd to override no matter what scope default mapping is in
	" <buffer> is necessary to override
	" augroup nerd_tree
	"     autocmd!
	"     autocmd FileType nerdtree nnoremap <buffer> J gt
	"     autocmd FileType nerdtree nnoremap <buffer> K gT
	" augroup END
	function! s:MakeNERDTreeCmds()
		let l:nerd_tree_cmds = {
					\ 't': MakeRunCommandsDictInfo('NERDTreeToggle', [], v:false, v:false),
					\ 'o': MakeRunCommandsDictInfo('NERDTreeFocus', [], v:false, v:false),
					\ 'v': MakeRunCommandsDictInfo('NERDTreeVCS', [], v:false, v:false),
					\ 'b': MakeRunCommandsDictInfo('NERDTreeFromBookmark', [], v:true, v:false),
					\ 'f': MakeRunCommandsDictInfo('NERDTreeFind', [], v:false, v:false),
					\ 'c': MakeRunCommandsDictInfo('NERDTreeCWD', [], v:false, v:false),
					\ 'r': MakeRunCommandsDictInfo('NERDTreeRefreshRoot', [], v:false, v:false),
					\ }
		function! s:NERDTreeCmds() closure
			return l:nerd_tree_cmds
		endfunction
	endfunction
	function! s:MakeNERDTreeFlagDict()
		let l:nerd_tree_flags = s:MakeRunCommandsFlagDict(':', ';')
		function! s:NERDTreeFlags() closure
			return l:nerd_tree_flags
		endfunction
	endfunction
	nnoremap <expr> [Chief]t RunCommandsExpr("NERDTree", <SID>NERDTreeCmds(), <SID>NERDTreeFlags())
endif
" --- || NERDTree || }}}

" {{{ || tagbar || ---
if exists('g:plugs["tagbar"]')
	let g:tagbar_type_go = {
				\ 'ctagstype' : 'go',
				\ 'kinds'     : [
					\ 'p:package',
					\ 'i:imports:1',
					\ 'c:constants',
					\ 'v:variables',
					\ 't:types',
					\ 'n:interfaces',
					\ 'w:fields',
					\ 'e:embedded',
					\ 'm:methods',
					\ 'r:constructor',
					\ 'f:functions'
				\ ],
				\ 'sro' : '.',
				\ 'kind2scope' : {
					\ 't' : 'ctype',
					\ 'n' : 'ntype'
				\ },
				\ 'scope2kind' : {
					\ 'ctype' : 't',
					\ 'ntype' : 'n'
				\ },
				\ 'ctagsbin'  : 'gotags',
				\ 'ctagsargs' : '-sort -silent'
				\ }
	nnoremap <Leader>o :TagbarToggle<CR>
	nnoremap <Leader>O :TagbarOpen fj<CR>
endif
" --- || tagbar || }}}

" {{{ || vim-surround || ---
if exists('g:plugs["vim-surround"]')
	" set characters and correspondng wrappers
	" value for variable have to be surrounded by "", not ''
	" pre-defined mappings that are useful are:
	" t: "<[tag]>\r</[tag]>" <- [tag] will be replaced by user input
	" f: "[function](\r)" <- [function] will be replaced by user input
	let g:surround_{char2nr('p')} = "(\r)"
	let g:surround_{char2nr('o')} = "[\r]"
	let g:surround_{char2nr('r')} = "{\r}"
	let g:surround_{char2nr('v')} = "<\r>"
	let g:surround_{char2nr('q')} = "\"\r\""
	let g:surround_{char2nr('x')} = "'\r'"
	let g:surround_{char2nr('d')} = "${\r}"
	let g:surround_{char2nr('D')} = "\"${\r}\""
	let g:surround_{char2nr('s')} = "$(\r)"
	let g:surround_{char2nr('S')} = "\"$(\r)\""
endif
" --- || vim-surround || }}}

" {{{ || vim-projectroot || ---
if exists('g:plugs["vim-projectroot"]')
	cnoreabbrev pj <C-r>=ProjectRootGuess()<C-m>
endif
" --- || vim-projectroot || }}}


" {{{ || auto-pairs || ---
if exists('g:plugs["auto-pairs"]')
	let g:AutoPairsFlyMode = 1
	let g:AutoPairsShortcutToggle = ''
	let g:AutoPairsShortcutFastWrap = '<M-w>'
	let g:AutoPairsShortcutJump = '<M-v>'
	let g:AutoPairsShortcutBackInsert = '<M-\>'
	let g:AutoPairsMapSpace = 0		" Enabling this maps <Space> to <C-]><C-R>=... and <C-]> is unwanted
	inoremap <silent> <Space> <C-g>u<C-r>=AutoPairsSpace()<CR>
	let g:AutoPairsMultilineClose = 0
endif
" --- || auto-pairs || }}}

" {{{ || vim-repeat || ---
if exists('g:plugs["vim-repeat"]')
	nmap <silent> U <Plug>(RepeatRedo)
endif
" --- || vim-repeat || }}}

" {{{ || syntastic || ---
if exists('g:plugs["syntastic"]')
	" Do not complete automatically
	let g:syntastic_mode_map = {
				\ "mode": "passive",
				\ "active_filetypes": [],
				\ "passive_filetypes": [] }
	let g:syntastic_always_populate_loc_list = 1
	let g:syntastic_aggregating_errors = 1
	let g:syntastic_auto_loc_list = 1
	let g:syntastic_check_on_open = 0
	let g:syntastic_check_on_wq = 0
endif
" --- || end of syntastic || }}}

" {{{ || vim-autoformat || ---
" tilde (~) must be expanded
let g:formatterpath = [expand('~').'/.local/bin']
" --- || vim-autoformat || }}}

" {{{ || easy-motion || ---
if exists('g:plugs["vim-easymotion"]')
	" this option unmap all easymotion-prefix including user defined ones
	" let g:EasyMotion_do_mapping = 0
	let g:EasyMotion_smartcase = 1
	let g:EasyMotion_use_upper = 1
	let g:EasyMotion_keys = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ;'
	let g:EasyMotion_enter_jump_first = 1
	let g:EasyMotion_space_jump_first = 1
	let g:EasyMotion_off_screen_search = 1
	" this disables highlighting by `n` command, but you need easymotion-next/prev to move around
	let g:EasyMotion_add_search_history = 1
	let g:EasyMotion_startofline = 0
	" mapping easymotion-prefix prevents <Leader><Leader> from being mapped
	" map <S-F12> <Plug>(easymotion-prefix)
	nmap s <Plug>(easymotion-prefix)
	vmap s <Plug>(easymotion-prefix)
	omap v <Plug>(easymotion-prefix)
	map f <Plug>(easymotion-fl)
	map F <Plug>(easymotion-Fl)
	map t <Plug>(easymotion-tl)
	map T <Plug>(easymotion-Tl)
	map s/ <Plug>(easymotion-sn)
	map s. <Plug>(easymotion-repeat)
	map <Bslash> <Plug>(easymotion-next)
	map <Bar> <Plug>(easymotion-prev)
endif
" --- || easy-motion || }}}
"
" {{{ || fzf.vim || ---
if exists('g:plugs["fzf.vim"]')
	imap <c-x><c-k> <plug>(fzf-complete-word)
	imap <c-x><c-f> <plug>(fzf-complete-path)
	imap <c-x><c-l> <plug>(fzf-complete-line)
	cnoreabbrev ff  Files
	cnoreabbrev fb  Buffers
	cnoreabbrev fla Lines
	cnoreabbrev fl  BLines
	cnoreabbrev fw  Windows
	cnoreabbrev fo  History
	cnoreabbrev f:  History:
	cnoreabbrev f/  History/
	cnoreabbrev fca Commits
	cnoreabbrev fc  BCommits
	cnoreabbrev fh  Helptags
endif
" --- || fzf.vim || }}}

" {{{ || ctrlp || ---
if exists('g:plugs["ctrlp.vim"]')
	" for now, just disable the default mapping to prevent from <C-p> to be overridden
	let g:ctrlp_map = '<F13>'
endif
" --- || ctrlp || }}}

" {{{ || UltiSnips || ---
if exists('g:plugs["ultisnips"]')
	let g:UltiSnipsExpandTrigger="<C-]>"
	let g:UltiSnipsJumpForwardTrigger="<C-s>"
	let g:UltiSnipsJumpBackwardTrigger="<M-s>"
	cnoreabbrev us call UltiSnips#
endif
" --- || UltiSnips || }}}
"
" {{{ || LanguageClient-neovim || ---
if exists('g:plugs["LanguageClient-neovim"]')
	set hidden
	let g:LanguageClient_changeThrottle = 0.5
	let g:LanguageClient_diagnosticsList = "Location"
	let g:LanguageClient_serverCommands = {
				\ 'go': ['gopls'],
				\ 'python': ['~/.local/bin/pyls']
				\ }
endif
" --- || LanguageClient-neovim || }}}

" {{{ || deoplete || ---
if exists('g:plugs["deoplete.nvim"]')
	let g:deoplete#enable_at_startup = 1
	if has('win32')
		" On Windows, it is 1 by default, and only available on nvim
		" Seems not necessary to change on nvim (fast enough already)
		" call deoplete#custom#option('num_processes', 2)
		" cmd is "python.exe" so deoplete (yarp?) cannot find it by default
		let g:python3_host_prog="python"
	endif
	" FIXME This tells deoplete to use 'omnifunc' for completion.
	" i.e. &omnifunc will be set to some deoplete function
	" But currently it fails to load matching from omnifunc
	" call deoplete#custom#option({
	"             \ 'complete_method': 'omnifunc',
	"             \})
	" FIXME these just don't work
	" call deoplete#custom#source('omni', 'input_patterns', {
	"             \ 'vim': '.*',
	"             \ 'javascript': '.*',
	"             \})
	" call deoplete#custom#source('omni', 'functions', {
	"             \ 'vim': ['syntaxcomplete#Complete'],
	"             \ 'javascript': [ 'tern#Complete', 'jspc#omni' ],
	"             \})
	" The below 2 lines are necessary, apparently.
	" HOWEVER, these disable normal omni completion as well.
	" i.e. when I press <C-x><C-o>, no match will be found.
	" let g:tern#command = ['tern']
	" let g:tern#arguments = ['--persistent']

	inoremap <silent> <expr> <C-i> pumvisible() ? "\<C-n>" : deoplete#manual_complete()
endif
" --- || deoplete || }}}

" --- || plugin mapping and option || }}}

" --- || key mapping || }}}

" {{{ || abbreviation || ---
cnoreabbrev ehco echo
cnoreabbrev tn tabnew
cnoreabbrev tm TabnewMulti
cnoreabbrev tnro tabnew <Bar> view
cnoreabbrev spro split <Bar> view
cnoreabbrev vsro vsplit <Bar> view
cnoreabbrev ts tab split
cnoreabbrev vb vertical sbuffer
cnoreabbrev tb tab sbuffer
cnoreabbrev vh vertical help <Bar> execute "normal! \<lt>C-w>80\<Bar>"<C-Left><C-Left><C-Left><C-Left><Left>
cnoreabbrev th tab help
cnoreabbrev bold browse oldfiles
cnoreabbrev st new <Bar> terminal
cnoreabbrev vt vnew <Bar> terminal
cnoreabbrev nt tabnew <Bar> terminal
cnoreabbrev tt SetTitle
" --- || abbreviation || }}}

" {{{ || netrw || ---
let g:netrw_winsize = 18
let g:netrw_banner = 0
" --- || netrw || }}}

" {{{ || functions || ---
" move back cursor before a command is executed
" offset moves down and right n lines/columns to the original position
function! Preserve(command, linoff, coloff)
	let l = line(".") + a:linoff
	let c = col(".") + a:coloff
	echom a:command
	execute a:command
	call cursor(l, c)
endfunction

fun s:RedrawCancel()
	mode
	echo 'Cancelled'
	return 0
endf

" getchar() with Ctrl+C to cancel
" This returns numeric 0 if interrupted, so the value is compared using 'is'
function! GetChar(escape_means_cancel)
	try
		call inputsave()
		let l:char = nr2char(getchar())
		if a:escape_means_cancel && l:char == "\<Esc>"
			return s:RedrawCancel()
		endif
		return l:char
	catch /^Vim:Interrupt$/
		return s:RedrawCancel()
	finally
		call inputrestore()
	endtry
endfunction

" input() with Ctrl+C to cancel
" This returns numeric 0 if interrupted, so the value is compared using 'is'
function! Input(empty_means_cancel, ...)
	let l:opts = {}
	if a:0 > 0
		if type(a:1) == v:t_dict " is dictionary
			let l:opts = a:1
		else
			let l:opts['prompt'] = (a:0 >= 1) ? a:1 : ''
			let l:opts['default'] = (a:0 >= 2) ? a:2 : ''
			if a:0 >= 3
				let l:opts['completion'] = a:3
			endif
		endif
	endif
	try
		call inputsave()
		let l:input = input(l:opts)
		if a:empty_means_cancel && l:input == ''
			return s:RedrawCancel()
		endif
		return l:input
	catch /^Vim:Interrupt$/
		return s:RedrawCancel()
	finally
		call inputrestore()
	endtry
endfunction

" add elements only if the specified list does not contain the same value
function! AddUniq(list, elm)
	if index(a:list, a:elm) == -1
		call add(a:list, a:elm)
	endif
endfunction

function! IsCtrlAlpha(char)
	let l:char_num = char2nr(a:char)
	return char2nr("\<C-a>") <= l:char_num && l:char_num <= char2nr("\<C-z>")
endfunction

" @case: 1 for lowercase, 2 for uppercase
function! ConvertCtrlCharToNormal(char, case)
	const [l:lowercase, l:uppercase] = [1, 2]
	const l:deltas = {
				\ l:lowercase: char2nr('a') - char2nr("\<C-a>"),
				\ l:uppercase: char2nr('A') - char2nr("\<C-a>"),
				\}

	let l:char_num = char2nr(a:char)
	if !IsCtrlAlpha(a:char)
		echoerr printf('Invalid argument: %s is not ctrl-{alphabet}', a:char)
		return
	endif

	let l:delta = get(l:deltas, a:case, '')
	if l:delta == ''
		echoerr printf('Invalid argument: case must be either %s', [l:lowercase, l:uppercase])
		return
	endif

	return nr2char(l:char_num + l:delta)
endfunction

function! Expander()
	echohl Identifier
	echo 'Ctrl+: [b]asename, [s]implename, [d]irname, [f]ullname, [p]wd'
	echohl NONE
	let l:char = nr2char(getchar())
	if l:char ==? "b" || l:char ==? "\<C-b>"
		let l:cmd = "\<C-r>=expand('%:t')\<CR>"
	elseif l:char ==? "s" || l:char ==? "\<C-s>"
		let l:cmd = "\<C-r>=expand('%:t:r')\<CR>"
	elseif l:char ==? "d" || l:char ==? "\<C-d>"
		let l:cmd = "\<C-r>=expand('%:p:h')\<CR>"
	elseif l:char ==? "f" || l:char ==? "\<C-f>"
		let l:cmd = "\<C-r>=expand('%:p')\<CR>"
	elseif l:char ==? "p" || l:char ==? "\<C-p>"
		let l:cmd = "\<C-r>=getcwd()\<CR>"
	else
		echohl WarningMsg | echo 'Not an available option: '.l:char | echohl NONE
		sleep 1
		" return space and backspace to clean up the msg in command line
		let l:cmd = "\<Space>\<BS>"
	endif

	return l:cmd
endfunction

function! SelectBtwCols(sln, spos, eln, epos)
	" NOTE: Use cursor() instead of '|' command
	" searchpairpos() reterns 'n' as in nth char rather than column number.
	" '|' goes to column number, so if the line is indented with tab, '|' misbehaves.
	" since tab is single character but takes up &shiftwidth columns
	" execute 'normal! '.l:spos.'|v'.l:epos.'|'
	silent execute printf("normal! :call cursor(%s, %s)\<CR>v:call cursor(%s, %s)\<CR>v`<", a:sln, a:spos, a:eln, a:epos)
endf

function! SelectCamelWord()
	let l:crntLine = line('.')
	let l:camelRegexp = '[A-Za-z][a-z]*'
	let [_, l:spos] = searchpos(l:camelRegexp, 'bc', l:crntLine)
	let [_, l:epos] = searchpos(l:camelRegexp, 'ce', l:crntLine)
	call SelectBtwCols(l:crntLine, l:spos, l:crntLine, l:epos)
endfunction

function! SelectPair(start, middle, end, include)
	" NOTE: searchpairpos works a little weird as illustrated below
	" With 'c' option, if the cursor is on the first char of 'start' string (with 'b' option, last char of 'end' string),
	" searchpairpos() cannot find the match.
	let [l:sln, l:spos] = searchpairpos(a:start, a:middle, a:end, 'bc')
	let [l:eln, l:epos] = searchpairpos(a:start, a:middle, a:end)
	if l:spos == 0 || l:epos == 0
		" no match was found
		return
	endif
	if !a:include
		let l:spos = l:spos + len(a:start)
		let l:epos = l:epos - len(a:end)
	endif
	call SelectBtwCols(l:sln, l:spos, l:eln, l:epos)
endfunction

" Select either function/method call, object property, or struct (including object itself)
function! SelectElement()
	let l:elemRegexp = '[A-Za-z0-9_.]\+[({]'
	let [l:sln, l:spos] = searchpos(l:elemRegexp, 'bc')
	let [l:eln, l:epos] = searchpos(l:elemRegexp, 'e')
	let l:lastchar = getline(l:eln)[l:epos-1]
	if l:lastchar =~ '[({]'
		let l:start = l:lastchar
		let l:end = ')'
		if l:lastchar == '{'
			let l:end = '}'
		endif
		let [l:eln, l:epos] = searchpairpos(l:start, '', l:end)
	endif
	call SelectBtwCols(l:sln, l:spos, l:eln, l:epos)
endf

function! SetTitle(title)
	let l:escapedTitle = escape(a:title, ' \')
	execute 'set titlestring=' . l:escapedTitle
	set title
endfunction
command! -nargs=1 SetTitle :call SetTitle(<q-args>)

" get full path of all window of all tab, then save them into @* or @"
" depending on the availability of 'clipboard' option
function! ClipAllWinTabPaths()
	let l:lasttabnr = tabpagenr()

	if has('clipboard')
		let l:register = '*'
	else
		let l:register = '"'
	endif

	let l:patharr = []
	tabdo windo call AddUniq(l:patharr, expand('%:p'))
	call setreg(l:register, join(l:patharr, "\n"))

	execute "tabnext " . l:lasttabnr

	if !has('clipboard')
		$ tabnew
		put
		global/^$/delete
	endif
endfunction
command! ClipAllWinTabPaths :call ClipAllWinTabPaths()

" Open files on each line one file in one tab
function! OpenFileOnEachLine() range
	" silent global/^$/delete
	" let l:linecnt = 1
	let l:cmd = ""
	" let l:totallinenum = line("$")
	" call cursor(1, 1)
	for l:linenum in range(a:firstline, a:lastline)
		call cursor(l:linenum, 1)
		let l:path = expand("<cfile>") 
		if !filereadable(l:path)
			continue
		endif
		let l:cmd .= "tabnew ".l:path." \<Bar> "
	endfor
	" while l:linecnt <= l:totallinenum
	"     call cursor(l:linecnt, 1)
	"     let l:cmd = l:cmd . "tabnew " . expand("<cfile>") . " \<Bar> "
	"     let l:linecnt = l:linecnt + 1
	" endwhile
	execute l:cmd
endfunction
command! -range=% OpenFileOnEachLine <line1>,<line2>call OpenFileOnEachLine()

" Open multiple files each in its own tab
" @... [path[]] Filepath to open. Wildcard is accepted.
function! TabnewMulti(...)
	let l:files = []
	for l:paths in a:000
		for l:node in glob(l:paths, 0, 1)
			" Get absolute path or it fails when the arguments contains
			" recursive wildcard and the expanded result contains files in
			" subdirectory as autocmd changes pwd to the file's containing
			" dirctory and relative path breaks.
			" Also exclude directories.
			if filereadable(l:node)
				call add(l:files, fnamemodify(l:node, ':p'))
			endif
		endfor
	endfor
	let l:filenum = len(l:files)
	if l:filenum == 0
		echohl WarningMsg | echo 'No matching file' | echohl NONE
		return
	endif
	let l:orgtabnr = tabpagenr()
	for l:file in l:files
		execute 'tabnew '.l:file
	endfor
	execute l:orgtabnr.'tabnext'
	" FIXME this message is not displayed
	echo printf('%s file%s opened', l:filenum, l:filenum > 1 ? 's' : '')
endfunction
command! -complete=file -nargs=+ TabnewMulti call TabnewMulti(<f-args>)

" store the output of command to register 'r'
function! RedirCmdOutputToReg(...)
	if empty(a:000)
		echoerr 'Argument required'
		return
	endif
	redir @r
	execute join(a:000, ' ')
	redir END
endfunction
command! -complete=command -nargs=+ RedirCmdOutputToReg :call RedirCmdOutputToReg(<f-args>)

" redirect the output of external command into console
function! OutputExtCmdToCmdlind(cmd)
	echo system(a:cmd)
endfunction
command! -complete=shellcmd -nargs=1 OutputExtCmdToCmdlind :call OutputExtCmdToCmdlind(<q-args>)

" redirect the output of external command into quickfix window
function! s:ExtCmdToQF(exprref, cmd)
	call a:exprref(a:cmd)
	let l:errornum = len(getloclist(0))
	if !l:errornum
		redraw
		echohl WarningMsg | echo 'No output from the command' | echohl NONE
		return
	endif
	execute 'lopen' . (l:errornum > 10 ? '' : l:errornum)
	set modifiable
	silent! %substitute/^|| //g
	set nomodified
	wincmd p
endfunction
function! s:LgetexprSystem(cmd)
	lgetexpr system(a:cmd)
endfunction
function! s:LaddexprSystem(cmd)
	laddexpr system(a:cmd)
endfunction
command! -complete=shellcmd -nargs=+ OutputExtCmdToQF :call <SID>ExtCmdToQF(function('s:LgetexprSystem'), <q-args>)
command! -complete=shellcmd -nargs=+ AppendExtCmdToQF :call <SID>ExtCmdToQF(function('s:LaddexprSystem'), <q-args>)

" redirect the output of external command into preview window
function! s:ExtCmdToPreview(cmd, append)
	if !a:append
		execute printf('pedit [%s]', a:cmd)
	endif

	try
		wincmd P
	catch /^Vim\%((\a\+)\)\=:E441:/
		call s:ExtCmdToPreview(a:cmd, v:false)
		return
	endtry

	let l:vimcmd = a:append ? '$read !' :'%! ' 
	execute l:vimcmd.a:cmd
	setlocal nomodified
	wincmd p
endfunction
command! -complete=shellcmd -nargs=+ OutputExtCmdToPreview call <SID>ExtCmdToPreview(<q-args>, v:false)
command! -complete=shellcmd -nargs=+ AppendExtCmdToPreview call <SID>ExtCmdToPreview(<q-args>, v:true)

function! SetOperatorFunc(funcname)
	execute 'set operatorfunc=' . a:funcname
	echohl Identifier | echon a:funcname | echohl NONE
	echon ' is being called. Enter motion key:'
endfunction

function! GetOperatorText(operatortype, noline)
	if a:operatortype ==# 'v'
		normal! `<v`>y
	elseif a:operatortype ==# 'char'
		normal! `[v`]y
	else
		if a:noline
			echohl WarningMsg
			echo "line-wise motion and line/block-wise selection is not supported"
			echohl NONE
			throw "Exception"
		endif

		normal! `[V`]y
	endif
	return @"
endfunction

function! GetVisualText()
	normal! gvy
	let l:result = getreg('"')
	normal! gv
	return l:result
endfunction

" Get ftplugins (including after) for the specified file type and return them as a list
function! GetFtplugins(filetype)
	let l:files = []
	let l:trailingfn = '/ftplugin/'.a:filetype.'.vim'
	let l:ftppath = s:vimdir.l:trailingfn
	let l:aftppath = s:vimdir.'/after'.l:trailingfn

	if filereadable(l:ftppath)
		call add(l:files, l:ftppath)
	endif
	if filereadable(l:aftppath)
		call add(l:files, l:aftppath)
	endif

	return l:files
endfunction

" Open ftplugin (including after) for the specified file type
function! OpenFtplugins(...)
	let l:files = []
	for l:ft in a:000
		let l:files += GetFtplugins(l:ft)
	endfor

	if empty(l:files)
		redraw
		echo 'No ftplugins found'
		return
	endif

	for l:file in l:files
		silent execute 'tabnew '.l:file
	endfor
endfunction
command! -complete=filetype OpenFtplugins :call OpenFtplugins(<f-args>)

" Set filetype again with the current buffer's file type
function! SetFt(...)
	if a:0
		let l:ft = a:1
	else
		let l:ft = &filetype
	endif
	execute 'set filetype='.l:ft
endfunction
command! -nargs=? -complete=filetype SetFt :call SetFt(<f-args>)
command! -nargs=? -complete=filetype SF :call SetFt(<f-args>)

" 'lmake' without moving to location list window
function! MyMake(...) abort
	let l:cmd = 'silent lmake! '.join(a:000)
	echohl Identifier | echo 'Making... ' | echohl NONE
	execute l:cmd
	let l:errorexists = QFOpenSmart(s:quickfix_mode_location, 0)
	" On linux console, bash console will be shown when making and vim is
	" brought back when make is done. This causes the contents of the file now
	" shown properly. 'redraw!' to fix it.
	if !(has('gui') || has('nvim'))
		redraw!
	endif
	if l:errorexists
		echohl WarningMsg | echon 'Failed :(' | echohl NONE
	else
		echohl Identifier | echon 'Done!' | echohl NONE
	endif
endfunction
command! -nargs=* MyMake :call MyMake(<f-args>)

" Display dictionary in accending order
function! DispOptions(title, option, message, ...) abort
	let l:SortFunc = (a:0 >= 1) ? a:1 : ''
	let l:key_name = (a:0 >= 2) ? a:2 : ''

	echohl Statement | echo a:title | echohl NONE
	for [k,v] in sort(items(a:option), l:SortFunc)
		echo printf('  %s: %s', k, (type(v) == v:t_dict ? v[l:key_name] : v))
	endfor
	unlet k v
	echohl Function | echo a:message | echohl NONE
endf

" Display dictionary in accending order in oneline
function! DispOptionsOneLine(title, option, ...) abort
	let l:SortFunc = (a:0 >= 1) ? a:1 : ''
	let l:key_name = (a:0 >= 2) ? a:2 : ''

	let l:output = []
	for [k,v] in sort(items(a:option), l:SortFunc)
		call add(l:output, printf('%s[%s]', (type(v) == v:t_dict ? v[l:key_name] : v), k))
	endfor
	unlet k v
	echohl Function | echo printf('-- %s --> %s: ', a:title, join(l:output, ", ")) | echohl NONE
endf

" Display dictionary in accending order for <expr> mapping
" (i.e. modify 'cmdheight' to avoid 'Press ENTER or ...')
function! DispOptionsExpr(title, option, message, ...) abort
	let l:SortFunc = (a:0 >= 1) ? a:1 : ''
	let l:key_name = (a:0 >= 2) ? a:2 : ''

	let l:org_cmdheight = &cmdheight
	" must be `let`, `execute set` does not work
	let &cmdheight = len(a:option) + 2
	mode " suppress white flash which somehow appears when expanding cmdline

	let l:output = []
	call add(l:output, a:title)
	for [k,v] in sort(items(a:option), l:SortFunc)
		call add(l:output, printf('  %s: %s', k, (type(v) == v:t_dict ? v[l:key_name] : v)))
	endfor
	unlet k v
	call add(l:output, a:message)
	echohl Question | echo join(l:output, "\n") | echohl NONE

	let &cmdheight = l:org_cmdheight
endf

" @header [string] string to prepend
" @footer [string] string to append
" @indent_level [int] number of space to add in front of each dict entry
" @1 [*] {func} argument for sort()
" @2 [string] if {dict} has nested dict, key for the entry to use
function! DictToListString(dict, sep, header, footer, indent_level, ...) abort
	let l:SortFunc = (a:0 >= 1) ? a:1 : ''
	let l:key_name = (a:0 >= 2) ? a:2 : ''

	let l:entry_format = repeat(' ', a:indent_level) . '%s' . a:sep . '%s'
	let l:list = []
	for [k, v] in sort(items(a:dict), l:SortFunc)
		call add(l:list, printf(l:entry_format, k, (type(v) == v:t_dict ? v[l:key_name] : v)))
	endfor
	unlet k v

	if a:header != ''
		call insert(l:list, a:header)
	endif
	if a:footer != ''
		call add(l:list, a:footer)
	endif

	return join(l:list, "\n")
endfunction

" `echo` without "Press ENTER and ..." by changing 'cmdheight' if {content}
" has more line number than 'cmdheight'.
" If {return_callback} is true, you can reset the 'cmdheight' by calling
" `reset_cmdheight()` of returned object. Otherwise 'cmdheight' is reset
" immediately (intended to use with getchar/input())
function! EchoAdjustingCmdheight(content, return_callback) abort
	let l:org_cmdheight = &cmdheight
	let l:cmdheight_changed = v:false

	let l:line_count = count(a:content, "\n") + 1
	" must be `let`, `execute set` does not work
	let &cmdheight = l:line_count

	mode " suppress white flash which somehow appears when expanding cmdline
	echohl Question | echo a:content | echohl NONE

	if a:return_callback
		let l:callback = {}
		function! l:callback.reset_cmdheight() closure
			let &cmdheight = l:org_cmdheight
		endfunction
		return l:callback
	endif

	let &cmdheight = l:org_cmdheight
endfunction

function! Toggler()
	let l:options = {
				\ 'l': 'list',
				\ 'p': 'paste',
				\ 'r': 'relativenumber',
				\ 'w': 'wrap'
				\ }
	call DispOptions('Toggle option', l:options, 'Press a key: ')
	let l:userinput = GetChar(v:true)
	" string == 0 is true so must return the default value
	let l:option = get(l:options, l:userinput, "")
	redraw	" clear concole so that 'Press ENTER or ...' will not be shown
	if l:option == ""
		" user press an unavailable key
		echohl WarningMsg
		echo printf('"%s" is not available.', l:userinput)
		echohl NONE
		return
	endif
	execute 'set '.l:option.'! '.l:option.'?'
endf
nnoremap _ :call Toggler()<CR>

" Function for sort() to sort 2D list based on the first element of inner array.
" Main usage is to sort list returned by items({dict}).
" Default algorithm of sort() has case insensitive sorting, but it does not
" guarantee that either UPPERCASE or lowercase precedes the other.
" This sort place lowercase before UPPERCASE within the same letter.
function! SortItemsCaseIns(one, two)
	let [l:key1, l:key2] = [a:one[0], a:two[0]]
	if l:key1 ==# l:key2
		return 1
	endif
	let l:keynum1 = char2nr(tolower(l:key1))
	let l:keynum2 = char2nr(tolower(l:key2))
	if l:keynum1 == l:keynum2
		" same char but different case -> lowercase should precedes UPPERCASE
		return char2nr(l:key1) > char2nr(l:key2) ? -1 : 1
	endif
	return l:keynum1 > l:keynum2 ? 1 : -1
endfunction

" Function for sort() to sort 2D list based on the second element of inner array.
" Main usage is to sort list returned by items({dict}).
" This essentially sort dict by value.
function! SortItemsByValue(one, two)
	return a:one[1] > a:two[1] ? 1 : -1
endfunction

" Like SortItemsByValue() but use nested value
function! SortItemsByNestedValue(key, one, two)
	return a:one[1][a:key] > a:two[1][a:key] ? 1 : -1
endfunction

" List up the commands in the given dictionary with keys to trigger.
" Pressing flag key changes the way the function behaves.
" @cmd_dict [dict] key: char to trigger the command, value: command to run
" @title [string] text to display when invoked
" @1 [dict] customised flag key
" @2 [string] sort function for displaying commands
" XXX no so cool
" - In 'modify' mode, argument can be added but original command cannot be modified
"   since completion does not work if there are preceding characters
function! RunCommands(cmd_dict, title, ...) abort
	let l:flag_keys = a:0 >= 1 ? a:1 : {}
	let l:SortFunc = a:0 >= 2 ? a:2 : ''

	function! s:ModProc() closure
		let l:selected_flag .= l:key_mod
		let l:modify = v:true
		echohl Function | echon l:key_mod | echohl NONE
	endfunction
	function! s:DispProc() closure
		redraw
		call DispOptions('Commands:', a:cmd_dict, 'Press a key: '. l:selected_flag, l:SortFunc, 'cmd')
	endfunction
	function! s:BangProc() closure
		let l:selected_flag .= l:key_bang
		let l:bang = v:true
		echohl Function | echon l:key_bang | echohl NONE
	endfunction

	let l:key_mod = get(l:flag_keys, 'mod', '-')
	let l:key_disp = get(l:flag_keys, 'disp', '_')
	let l:key_bang = get(l:flag_keys, 'bang', '!')
	let l:flag_dict = {
				\ l:key_mod: {'desc': 'Modify command', 'func': function('s:ModProc')},
				\ l:key_disp: {'desc': 'Display commands', 'func': function('s:DispProc')},
				\ l:key_bang: {'desc': 'Run with !', 'func': function('s:BangProc')},
				\}
	call DispOptionsOneLine(a:title, l:flag_dict, '', 'desc')

	let l:selected_flag = ''
	let [l:modify, l:bang] = [v:false, v:false]
	while v:true
		let l:user_input = GetChar(v:true)
		if l:user_input is 0
			return
		endif
		" remove() throws an error if key does not exist
		silent! let l:flag_info = remove(l:flag_dict, l:user_input)
		let l:flag_selected_or_user_input_is_not_flag = flag_info is 0
		if l:flag_selected_or_user_input_is_not_flag
			break
		endif
		call l:flag_info['func']()
	endwhile

	redraw
	let l:cmd_info = get(a:cmd_dict, l:user_input, {})
	if empty(l:cmd_info)
		" user press an unavailable key
		echohl WarningMsg | echo printf('"%s" is not available.', l:user_input) | echohl NONE
		return
	endif

	let l:cmd = l:cmd_info.cmd
	if l:cmd_info.always_modify && !l:modify
		let l:modify = v:true
	endif
	if l:bang && l:cmd_info.bangable
		let l:cmd .= '!'
	endif

	if l:modify
		let l:input_opt = {'prompt': ':' . l:cmd . ' '}
		if l:cmd_info.completion != ''
			let l:input_opt['completion'] = l:cmd_info.completion
		endif
		let l:cmd_arg = Input(v:false, l:input_opt)
		if l:cmd_arg is 0
			return
		endif
		let l:cmd .= l:cmd_arg == '' ? '' : ' ' . l:cmd_arg
		call histadd(':', l:cmd)
	else
		echo l:cmd
	endif

	execute l:cmd
endfunction

" @cmd [string] command to run
" @args [list] list of dist which is {value: [string], eval: [bool]}
" @always_modify [bool] whether to always modify the command
" @bangable [bool] if false, bang flag will be ignored and command is run without !
function! MakeRunCommandsDictInfo(cmd, args, always_modify, bangable) abort
	return {
				\ 'cmd': a:cmd,
				\ 'args': a:args,
				\ 'always_modify': a:always_modify,
				\ 'bangable': a:bangable,
				\}
endfunction

function! MakeRunCommandsDictInfoArgs(list_list) abort
	let l:args = []
	for l:arg in a:list_list
		let l:value = l:arg[0]
		let l:eval = len(l:arg) > 1 ? l:arg[1] : v:false
		call add(l:args, {'value': l:value, 'eval': l:eval})
	endfor
	return l:args
endfunction

" XXX not so cool
" - hard to update selected flag on cmdline
" - command reference cannot help but being single color
" - message/cmd list in cmdline gets overwritten if something is output
"   to cmdline (e.g. Goinfo by vim-go)
function! RunCommandsExpr(title, cmds, ...) abort
	let l:flag_keys = a:0 > 0 && type(a:1) == v:t_dict ? a:1 : {}
	let l:SortFunc = a:0 >= 2 ? a:2 : ''

	function! s:ModProc() closure
		let l:modify = v:true
	endfunction
	function! s:DispProc() closure
		redraw
		call EchoAdjustingCmdheight(l:output, v:false)
	endfunction
	function! s:BangProc() closure
		let l:bang = v:true
	endfunction
	function! s:EvalCmdArgs(cmd_key, cmd_info) abort
		let l:cmd_info = copy(a:cmd_info)

		if empty(a:cmd_info.args)
			let l:cmd_info.desc = l:cmd_info.cmd
			return l:cmd_info
		endif

		let l:new_args = []
		for l:arg in l:cmd_info.args
			call add(l:new_args, l:arg.eval ? eval(l:arg.value) : l:arg.value)
		endfor
		let l:cmd_info.args = l:new_args
		let l:cmd_info.desc = l:cmd_info.cmd . ' ' . join(l:new_args, ' ')
		return l:cmd_info
	endfunction

	let l:key_mod = get(l:flag_keys, 'mod', '-')
	let l:key_disp = get(l:flag_keys, 'disp', '_')
	let l:key_bang = get(l:flag_keys, 'bang', '!')
	let l:flag_dict = {
				\ l:key_mod: "Modify command",
				\ l:key_disp: "Display commands",
				\ l:key_bang: "Run with !",
				\}
	let l:flag_dict = {
				\ l:key_mod: {'desc': 'Modify command', 'func': function('s:ModProc')},
				\ l:key_disp: {'desc': 'Display commands', 'func': function('s:DispProc')},
				\ l:key_bang: {'desc': 'Run with !', 'func': function('s:BangProc')},
				\}
	call DispOptionsOneLine(a:title, l:flag_dict, '', 'desc')

	let l:cmds = map(copy(a:cmds), function('s:EvalCmdArgs'))
	let l:output = DictToListString(l:cmds, ': ', a:title, 'Press a key: ', 2, l:SortFunc, 'desc')

	let [l:modify, l:displaying, l:bang] = [v:false, v:false, v:false]
	while v:true
		let l:user_input = GetChar(v:true)
		if l:user_input is 0
			return
		endif
		" remove() throws an error if key does not exist
		silent! let l:flag_info = remove(l:flag_dict, l:user_input)
		let l:flag_selected_or_user_input_is_not_flag = flag_info is 0
		if l:flag_selected_or_user_input_is_not_flag
			break
		endif

		call l:flag_info['func']()
	endwhile
	mode

	let l:cmd_info = get(l:cmds, l:user_input, {})
	if empty(l:cmd_info)
		" user press an unavailable key
		echohl WarningMsg | echo printf('"%s" is not available.', l:user_input) | echohl NONE
		return
	endif

	if !l:modify && l:cmd_info.always_modify
		let l:modify = v:true
	endif
	let l:cmd = l:cmd_info.cmd
	if l:bang && l:cmd_info.bangable
		let l:cmd .= '!'
	endif
	let l:arg = len(l:cmd_info.args) == 0 ? '' : ' ' . join(l:cmd_info.args)

	return ':' . l:cmd . l:arg . (l:modify ? "\<Space>": "\<CR>")
endfunction

function! s:MakeRunCommandsFlagDict(...)
	let l:dict = {}
	if a:0 >= 1
		let l:dict['mod'] = a:1
	endif
	if a:0 >= 2
		let l:dict['disp'] = a:2
	endif
	if a:0 >= 3
		let l:dict['bang'] = a:3
	endif
	return l:dict
endfunction

function! s:diff(...)
	if a:0 != 2
		echoerr 'Diff takes exactly 2 arguments'
		return
	endif

	let l:msgFileNotExists = '%s does not exist'
	if !filereadable(a:1)
		echoerr printf(l:msgFileNotExists, a:1)
		return
	endif
	if !filereadable(a:2)
		echoerr printf(l:msgFileNotExists, a:2)
		return
	endif

	let l:fullpath1 = fnamemodify(a:1, ';p')
	let l:fullpath2 = fnamemodify(a:2, ';p')
	execute 'tabnew '.l:fullpath1
	execute 'diffsplit '.l:fullpath2
endfunction
command! -complete=file -nargs=+ Diff :call s:diff(<f-args>)

function! IsRegMultiline(reg)
	let l:reg_content = getreg(a:reg)
	return match(l:reg_content, '\r\|\n') >= 0
endfunction

" Run find & grep, then put result in quickfix window
" @edit: whether to edit commands
" @pattern: grep pattern
" @1: path for find
" @2: -name option for find
function! FindGrep(edit, pattern, ...) abort
	let l:path = a:0 >= 1 ? a:1 . ' ' : ''
	let l:filename = a:0 >= 2 ? '-name ' . a:2 . ' ' : ''
	let l:base_cmd = printf('find %s%s-type f -exec grep -Hn %s {} \;', l:path, l:filename, a:pattern)
	let l:cmds = a:edit ? Input(v:true, '', l:base_cmd, 'file') : l:base_cmd
	if l:cmds is 0
		return
	endif

	let l:results = systemlist(l:cmds)
	if v:shell_error
		redraw
		echohl WarningMsg | echo join(l:results) | echohl NONE
		return
	endif
	if empty(l:results)
		redraw
		echo 'No match found'
		return
	endif

	let l:qflists = []
	for l:result in l:results
		let l:info=[]
		call substitute(l:result, '\v(.*):(\d+):(.*)', '\=extend(l:info, [submatch(1), submatch(2), submatch(3)])', '')
		call add(l:qflists, {
					\ 'filename': l:info[0],
					\ 'lnum': l:info[1],
					\ 'text': l:info[2],
					\})
	endfor
	call setqflist(l:qflists)
	call setqflist([], 'a', {'title': l:cmds})
	call QFOpenSmart(s:quickfix_mode_quickfix, 0)
endfunction
command! -bar -bang -complete=file -nargs=* FindGrep call FindGrep(<bang>1, <f-args>)
cnoreabbrev fig FindGrep <bar> " <pattern> [path] [filename]<HOME><C-Right>
" --- || functions || }}}

" load local vimrc
call s:MakeNERDTreeCmds()
call s:MakeNERDTreeFlagDict()

if exists('g:plugs["vim-projectroot"]')
	silent! execute 'source '.projectroot#guess().'/.vimrc_local'
endif
